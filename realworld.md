# next-real-world

## About

## [Demo] [RealWorld]

This codebase was created to demonstrate a fully fledged fullstack application built with Next.js, Apollo GraphQL stack and Prisma including CRUD operations, authentication, routing, pagination, and more.

## Used Stacks

### backend

- [Prisma] ORM (v4.0 seems supports Node version 14 or later)
- [Apollo Server] mounted on the API route of Next.js pages
- [Nexus] as a code-first GraphQL schema generator

### frontend

- [Next.js]
- [Apollo Client] together with [GraphQL Code Generator]
- [Tailwind CSS]

## Features

- **Pagination**: use Prisma cursor-based query as well as Apollo Client `fetchMore` approach to implement a infinity load-more feature on the feed list and comment list.
- **Form Validation**: including a [Yup] schema check and [React Hook Form] for frontend form validation.

## Folder Structure

- `pages` All pages of a regular Next.js app.
- `pages/api/index.ts` The API route, mounting a GraphQL server instance within a Prisma client.
- `components` Contains all page components.
- `generated` Codes generated by Nexus and GraphQL Code Generator.
- `lib/api` Schema definitions of the GraphQL server.
- `lib/api/prisma.ts` Prisma client configs here.
- `lib/cache/index.ts` Cache config of Apollo client.
- `lib/schemas` Schema definitions for the frontend.
- `lib/constants.ts` App configs init.
- `prisma/schema.prisma` Definitions of database.
- `config.js` Build configs used in `next.config.original.js`.

## Getting Started

### Run local mysql server through Docker

- (Womb-structions ðŸ¶)
- Run the Docker Desktop app
- `$ docker pull mysql/mysql-server:latest`
  - pull the image where `mysql` is the org, `mysql-server` is the image name and `latest` is the tag, which is typically the version ex. 8.0, 8.1 see [dockerhub of mysql](https://hub.docker.com/_/mysql)
- `$ docker run --name=mysql_container -p 3306:3306 -e MYSQL_ROOT_PASSWORD=pass -d mysql/mysql-server:latest`
  - run the image as a container, passing it parameters to create the root user
  - `mysql_container` is the name of the container
  - `-p` means map port 3306 of localhost (where this container is running) to 3306 inside the container
- `$ docker exec -it mysql_container mysql -uroot -p`
  - connect to the container as the admin user, enter the password of "pass" when prompted

```
-- These commands are to be run when you are connected to the mysql server as the root user
-- You'll see "Welcome to the MySQL monitor."
-- Alternatively, you can connect via Dbeaver, etc...
-- For mysql commands, -- is a comment, so run the ones without --

-- shows you all databases in this server
SHOW DATABASES;

-- select a database to use and query etc...
USE mysql;

-- show all tables of the db you are connected to, these are auto created
SHOW TABLES;

-- show all columns of the user table, these are database users NOT app users;
SHOW COLUMNS FROM user;

-- select just the user column from the user table
SELECT user FROM user;
```

### Create new database user

The original readme.md had these instructions for the app to connect to the db

> And setup your owner MySQL server config in a `.env` file(see example in `.env.example`)
>
> ```env
> DATABASE_URL="mysql://root:pass@localhost/real_blog?useUnicode=true&characterEncoding=utf8&useSSL=false"
> ```

- (Your `.env` file would at the repo root)

However, this didn't seem to work... (chargeback), possibly a host restriction issue.
Here's what worked, creating new credentials for the app to connect to the db, which is also a better practice because you don't want your app to use the most privileged user (root) to connect to the db.

- Type via the existing terminal with the connection

```
-- create a new user and password
CREATE USER 'app'@'%' IDENTIFIED BY 'pass';

-- verify new user created and check privileges, Select_priv should be (N)
select user, Select_priv from user where user = 'app';

-- Grant all privileges to this user (not best practice to grant all but yolo)
GRANT ALL PRIVILEGES ON *.* TO 'app'@'%';

-- "save" changes
FLUSH PRIVILEGES;

-- check privileges, Select_priv should be (Y)
select user, Select_priv from user where user = 'app';

-- disconnect from mysql server and the container
exit
```

- Test that you can connect via this user
- `docker exec -it mysql_container mysql -u app -p`

```
-- shows the existing dbs, "real_blog" should NOT be here
-- but notice that we see less dbs than when we were logged as root
SHOW DATABASES;
-- don't exit
```

### Connect the app to the db

- Follow the original readme instructions

And setup your owner MySQL server config in a `.env` file(see example in `.env.example`)

```env
DATABASE_URL="mysql://root:pass@localhost/real_blog?useUnicode=true&characterEncoding=utf8&useSSL=false"
```

- Does this url string look correct?
- Replace it with the correct values because you are smart (use the `app` database user credentials)

### Run the application

Install dependencies

```bash
yarn
yarn dev
```

- You should see `prisma:info Starting a mysql pool with 5 connections.` but the app shouldn't work. Why?

```env
DATABASE_URL="mysql://root:pass@localhost/real_blog?useUnicode=true&characterEncoding=utf8&useSSL=false"
```

`/real_blog` means use the real_blog database, which doesn't exist yet... (you can `SHOW DATABASES;`) we need to create that.

### Run database migration script

- First look at `/prisma` there should just be a `schema.prisma` file
- This file determines what the database schema will be
- Specifically it generates the SQL that will be executed

- Run a Prisma migration script on your database

```bash
yarn db:migrate
```

- Look at `/prisma` there is now a `/migrations` which contains the sql
- When you make schema changes again in the future i.e. change the `schema.prisma` file, you will run the above command again, which will generate the next incremental SQL to run
- This is much better than just YOLO-running SQL because

1. There is only one source of truth `schema.prisma`
2. The SQL to revert the SQL migration is also automatically generated so you can undo mistakes
3. We can version control the changes.

The app homepage should now work and you should see

> "No articles are here... yet"

- Type via the existing terminal with the connection

```
-- real_blog should be here now
SHOW DATABASES;

-- use the db
USE real_blog;

-- Should show all your blog domain tables
SHOW TABLES;

exit;
```

### JWK misc

- Now back to the original instructions that lets you run the app locally even though is has authentication on
- No idea what's really happening here but just follow it..

Next, generate a JWK key pairs for the JWT based authentication, this script just print out the key pairs in the console

```bash
yarn generate:jwk
```

You should put the new generated PRIVATE_JWK into the `.env` file and the PUBLIC_JWK to `lib/constants.ts` as below

IT IS IMPORTANT THAT THIS IS A SINGLE LINE WITH NO SPACES exactly as the console outputs

```env
PRIVATE_JWK={your_generated_private_jwk}
```

```typescript
export const PUBLIC_JWK = {
  kty: "RSA" as const,
  ...
};
```

- You should be able to sign up / login and use all features
- You can click "stop" for your container in Docker Desktop to stop the mysql-server

### Database creation in the real world

- Database creation in the real world is not so different
- You choose an engine (postgrest, mysql, etc...) and you do many configurations as you can see in this [AWS guide](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_CreateDBInstance.html)
- You do ultimately generate the same username / password, see
- Step 10. "To enter your master password, do the following:" ...

### Remainder misc

- Below is the remainder of the original instructions that are not worth doing (for now)

Point [http://localhost:3000](http://localhost:3000) to the app's home page and [http://localhost:3000/api](http://localhost:3000/api) would redirect to Apollo Studio to show all the GraphQL API(Only accessible in a development env)

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js/) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/deployment) for more details.

## Deploy on ECS

- see example [repo](https://github.com/vercel/next.js/tree/canary/examples/with-docker)

[Demo]: https://next-real-world.vercel.app
[RealWorld]: https://github.com/gothinkster/realworld
[Prisma]: https://github.com/prisma/prisma
[Apollo Server]: https://github.com/apollographql/apollo-server
[Apollo Client]: https://github.com/apollographql/apollo-client
[Nexus]: https://github.com/graphql-nexus/nexus
[GraphQL Code Generator]: https://github.com/dotansimha/graphql-code-generator
[Tailwind CSS]: https://github.com/tailwindlabs/tailwindcss
[Next.js]: https://github.com/vercel/next.js
[Yup]: https://github.com/jquense/yup
[React Hook Form]: https://github.com/react-hook-form/react-hook-form
